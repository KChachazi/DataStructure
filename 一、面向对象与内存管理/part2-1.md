# Updates

续```part2-1.md```继续写

前面`part1`的一系列文章将C++面向对象的基本内容介绍完毕，接下来我们将探讨C++中有关内存管理的概念和方式方法。

接下来的内容主要包含，栈与堆的内存分配，`new/delete`与`malloc/free`，**RAII思想**，三/五法则和零法则。

## 引言

学习C++必须掌握内存管理，因为它是程序性能、稳定性与资源控制的核心。C++直接操作内存能实现高效资源利用，但也要求开发者承担内存安全责任。

## 栈与堆的内存分配

### 基本概念

要开始学习C++的内存管理，首先需要明确C++的内存概念。

C++的内存主要分为四个部分：代码区、全局/静态区、栈区、堆区。其中我们将要讨论的主要是栈区和堆区，也就是栈内存和堆内存。

| 内存区域          | 说明                                    |
| ------------- | ------------------------------------- |
| **代码区**       | 存放程序的机器指令（函数体、可执行代码）                  |
| **全局/静态区**    | 存放全局变量、静态变量、常量等                       |
| **栈区（Stack）** | 自动存储区。函数调用时系统自动分配，函数返回时自动释放           |
| **堆区（Heap）**  | 动态分配区。由程序员通过 `new` / `delete` 控制分配与释放 |

其中，栈内存由编译器自动管理，而堆内存可以由我们管理。

### 栈内存机制与特性

#### 栈内存的机制

栈内存是由系统自动管理的连续内存区域，其分配与释放与“数据结构”中的栈逻辑相同，均为严格的**后进先出**。

栈内存在程序运行中的主要用途为：
- 存储函数调用上下文(如`$sp`)
- 维护线程执行状态
- 通过CPU寄存器直接管理内存分配

#### 栈内存的特性

在机组的学习和写简单的汇编递归的经验之下，不难体会到栈内存首先具有的特性也是优势就是**分配/释放仅需移动`$sp`指针，因而是$O(1)$的**。

此外，栈内存的**生命周期与函数作用域严格绑定**，大小也是**固定步长**决定的。而且，栈内存的操作是由CPU寄存器直接操作，因此**访问速度极快**。

### 堆内存机制与特性

#### 堆内存的机制

堆内存是程序运行时可动态分配的内存区域，相比自动管理的栈内存，堆内存的设计是为了代码编写者更自由地对内存进行管理。

更自由的管理体现在内存块可以**以任意顺序分配和释放，支持动态调整大小，允许指针间接访问**。

不过自由之外还需要安全，因此要使用堆内存**必须在代码中显式请求分配/释放**。

#### 堆内存的特性

##### 自由的堆内存

相比于完全由系统自动管理的栈内存，堆内存是几乎完全由程序员来操作的内存。

当在代码中显式请求分配/释放时，堆内存就会开始/结束其生命周期。堆内存的生命周期从显式请求后一直**持续到显示释放或程序终止**。

而且，堆内存的容量**仅受系统可用内存限制**。

##### 自由的代价

堆内存固然有优势特性——自由，但是要实现这种自由，一定要付出 **“自由的代价”**。

其代价之一就是**内存碎片**。

内存碎片是指堆内存空间中存在许多小的、不连续的空闲内存块。这些内存块虽然总和很大，但是由于彼此并不连续，导致无法满足一次较大的内存分配请求。内存碎片可以主要分为外部碎片和内部碎片。其中从成因角度看，内部碎片是分配器出于对齐或管理方便的目的分配多于程序实际请求大小的内存而产生的，外部碎片则是分散在已分配内存块之间的空闲内存。我们通常关注的是**外部碎片**，下面的内存碎片也特指外部碎片。

我们来简单模拟一下内存碎片的产生过程。
```cpp
// 初始堆状态：[ 1024 Bytes Free ]

A = malloc(200);
B = malloc(100);
C = malloc(200);
D = malloc(100);
// [ A:200 ][ B:100 ][ C:200 ][ D:100 ][ Free:424 ]

free(A);
free(C);
// [ Free:200 ][ B:100 ][ Free:200 ][ D:100 ][ Free:424 ]

E = malloc(300);
// 寻找第一个大于 300 的内存碎片
// [ Free:200 ][ B:100 ][ Free:200 ][ D:100 ][ E:300 ][ Free:124 ]

F = malloc(250);
// 由于分隔开的内存碎片均小于 250
// 尽管总空闲 524 > 250，仍分配失败
```

如上就是一个内存碎片产生的可能机制。

内存碎片会导致内存的利用率降低，降低缓存的局部性。

##### 何以自由

从前面的机制介绍中思考，很自然就能体会到堆内存的特性与其**自由和自由的实现方式**强相关。

堆内存的核心机制包含了不同大小，不同生命周期的内存区域，要管理这样的区域就需要相应的分配算法，分配算法的取舍也能有效缓解诸如内存碎片的问题。

接下来我们尝试分析算法的设计要求。

对于分配算法的设计，主要关注点有三：
- 性能，即时间复杂度
- 碎片率
- 内存利用率

这三点构成了一个性能三角，不同的算法需要在这个三角中寻找一个平衡点。原本笔者期待在这里学习同时编写有关内存分配主流算法的思路，权衡，甚至实现，不过其内容涵盖完全可以作为单独一篇文章，因此挖坑，后续可能会出ex篇来介绍。

### 栈与堆的分配区别

来看下面一个实例：

```cpp
class Box {
public:
    Box(int v) : value(v) {
        std::cout << "Box constructed: " << value << '\n';
    }
    ~Box() {
        std::cout << "Box destructed: " << value << '\n';
    }
private:
    int value;
};

int main() {
    std::cout << "=== 栈上对象 ===\n";
    Box stackBox(1);

    std::cout << "=== 堆上对象 ===\n";
    Box* heapBox = new Box(2);

    std::cout << "=== 程序结束 ===\n";
    delete heapBox;
}
```

执行可以得到如下的输出：

```text
=== 栈上对象 ===
Box constructed: 1
=== 堆上对象 ===
Box constructed: 2
=== 程序结束 ===
Box destructed: 2
Box destructed: 1
```

在这个例子中我们可以明确感受到先前讲到的栈内存与堆内存的区别，并将其总述为下面的表格。

| 操作                | 内存区域 | 生命周期          | 释放方式   |
| ----------------- | ---- | ------------- | ------ |
| `Box stackBox(1)` | 栈    | 随作用域结束自动销毁    | 自动调用析构 |
| `new Box(2)`      | 堆    | 直到显式释放 | 必须手动释放 |

在使用堆内存的时候要小心隐式问题，主要是内存泄漏和内存多重释放。

## `new/delete`与`malloc/free`

首先，我们用一个表格来概括地介绍二者的区别，随后我们用几个代码来分别详细介绍。

|        | `malloc/free` | `new/delete` |
| --------- | ------------- | ------------ |
| 来源        | C 语言库函数       | C++ 运算符      |
| 是否类型安全    | 否             | 是            |
| 是否调用构造/析构 | 否             | 是            |
| 是否可重载     | 否             | 是            |
| 用途        | 原始内存操作        | 管理 C++ 对象    |
| 混用后果      | 未定义行为         | -            |

### `malloc/free`

`malloc/free`来源于C语言的库函数，作用为分配/释放原始内存。因而在使用过程中与C++面向对象契合度极低，不会自动调用构造/析构函数。

```cpp
Person *p = (Person *)malloc(sizeof(Person));
free(p);
// 仅分配对应大小内存，不会主动调用构造/析构函数
```

### `new/delete`

`new/delete`是C++的运算符，其功能就是分配并构造/析构并释放，因而是天然面向对象的。它们在一次执行中分别完成的任务为：调用`operator new`分配足够的内存，并调用构造函数初始化对象，最后返回对应指针；调用析构函数，随后调用`operator delete`释放内存。

我们用一个实例来验证上面的描述。

```cpp
class sample {
public:
    int data;
    char buffer[256];
    sample() {
        std::cout << "Constructor called." << std::endl;
    }

    ~sample() {
        std::cout << "Destructor called." << std::endl;
    }

    static void* operator new(size_t size) {
        std::cout << "Custom new operator called. Size: " << size << '\n';
        void* p = malloc(size);
        return p;
    }

    static void operator delete(void* p) {
        std::cout << "Custom delete operator called." << '\n';
        free(p);
    }
};

int main() {
    sample* obj = new sample;
    delete obj;
    return 0;
}
```

当我们运行上面的代码，可以得到如下的输出:

```text
Custom new operator called. Size: 260
Constructor called.
Destructor called.
Custom delete operator called.
```

这个输出与先前的描述是对应的。

### Placement new(定位new)

挖坑

## **RAII思想(资源获取即初始化)**

> **RAII(Resource Acquisition Is Initialization)** 是 C++ 的核心内存管理哲学。
> 它要求在对象构造时获取资源，在析构时释放资源，从而让资源的生命周期与对象的生命周期完全绑定。

简单来说，**RAII** 的主张就是“谁申请则谁销毁；构造时申请，析构时释放。”这种设计思想是为了解决传统资源管理中忘记关闭、释放等众多手动管理的复杂问题。

**RAII** 在内存管理、锁管理、数据库连接等多个场景下均有应用，同时还保证了异常安全、代码简洁。

接下来我们主要的讨论将限制在 **RAII** 思想在内存管理上的应用，进而**最核心、最常用**的也就是`std::unique_ptr, std::shared_ptr, std::weak_ptr`。

### `std::unique_ptr`

### `std::shared_ptr`

### `std::weak_ptr`

## 三/五法则和零法则

