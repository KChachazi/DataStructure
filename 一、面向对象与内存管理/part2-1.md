# Updates

续```part2-1.md```继续写

前面`part1`的一系列文章将C++面向对象的基本内容介绍完毕，接下来我们将探讨C++中有关内存管理的概念和方式方法。

接下来的内容主要包含，栈与堆的内存分配，`new/delete`与`malloc/free`，**RAII思想**，三/五法则和零法则。

## 引言

学习C++必须掌握内存管理，因为它是程序性能、稳定性与资源控制的核心。C++直接操作内存能实现高效资源利用，但也要求开发者承担内存安全责任。

## 栈与堆的内存分配

### 基本概念

要开始学习C++的内存管理，首先需要明确C++的内存概念。

C++的内存主要分为四个部分：代码区、全局/静态区、栈区、堆区。其中我们将要讨论的主要是栈区和堆区，也就是栈内存和堆内存。

| 内存区域          | 说明                                    |
| ------------- | ------------------------------------- |
| **代码区**       | 存放程序的机器指令（函数体、可执行代码）                  |
| **全局/静态区**    | 存放全局变量、静态变量、常量等                       |
| **栈区（Stack）** | 自动存储区。函数调用时系统自动分配，函数返回时自动释放           |
| **堆区（Heap）**  | 动态分配区。由程序员通过 `new` / `delete` 控制分配与释放 |

其中，栈内存由编译器自动管理，而堆内存可以由我们管理。

### 栈内存机制与特性

#### 栈内存的机制

栈内存是由系统自动管理的连续内存区域，其分配与释放与“数据结构”中的栈逻辑相同，均为严格的**后进先出**。

栈内存在程序运行中的主要用途为：
- 存储函数调用上下文(如`$sp`)
- 维护线程执行状态
- 通过CPU寄存器直接管理内存分配

#### 栈内存的特性

在机组的学习和写简单的汇编递归的经验之下，不难体会到栈内存首先具有的特性也是优势就是**分配/释放仅需移动`$sp`指针，因而是$O(1)$的**。

此外，栈内存的**生命周期与函数作用域严格绑定**，大小也是**固定步长**决定的。而且，栈内存的操作是由CPU寄存器直接操作，因此**访问速度极快**。

### 堆内存机制与特性

#### 堆内存的机制

堆内存是程序运行时可动态分配的内存区域，相比自动管理的栈内存，堆内存的设计是为了代码编写者更自由地对内存进行管理。

更自由的管理体现在内存块可以**以任意顺序分配和释放，支持动态调整大小，允许指针间接访问**。

不过自由之外还需要安全，因此要使用堆内存**必须在代码中显式请求分配/释放**。

#### 堆内存的特性

从前面的机制介绍中思考，很自然就能体会到堆内存的特性与其**自由和自由的实现方式**强相关。



##### 分配算法

堆内存的核心机制包含了不同大小，不同生命周期的内存区域，要管理这样的区域就需要相应的算法。接下来我们尝试分析算法的设计要求。

对于分配算法的设计，主要关注点有三：
- 性能，即时间复杂度
- 碎片率
- 内存利用率

这三点构成了一个性能三角，不同的算法需要在这个三角中寻找一个平衡点。

### 栈与堆的分配区别

来看下面一个实例：

```cpp

```

## `new/delete`与`malloc/free`

## **RAII思想(资源获取即初始化)**

## 三/五法则和零法则