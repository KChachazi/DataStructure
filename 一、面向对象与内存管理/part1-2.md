# Updates

续```part1.1.md```继续写

前面文章涉及了基本的面向对象的四大核心，同时也重点讨论了它们在C++中的实现方式，接下来将对C++ class的细节和行为控制进行进一步的学习探索

# 面向对象与内存管理

## 深拷贝与浅拷贝

之前文章提及了C++类的构造函数和析构函数，这是进行类初始化的基本操作。然而需要注意的一点是，在复杂工程中经常会出现拷贝的问题，而仅靠默认的构造/析构函数容易导致隐性错误的出现，进而编译正常，但运行时错误。为了尽可能避免隐性错误的出现，对拷贝方式进行学习与讨论，进而灵活设计拷贝方式是非常重要的。

### 默认下的拷贝

在C++中，默认的拷贝方式一般是浅拷贝。

### 浅拷贝

浅拷贝非常简单，顾名思义就是进行浅层数据的拷贝。（此处笔者本来想要引入左值和右值的含义，不过详细展开需要单独的一节，因此也先挖坑）

#### 浅拷贝的实现

来看如下的一个简单类A：

```cpp
class A {
public:
    int val;
    char* name;
    A(int v, const char* n) : val(v) {
        name = new char[strlen(n) + 1];
        strcpy(name, n);
    }
    ~A() {
        delete[] name;
    }
};
```

我们执行下面的代码段：
```cpp
A a1(10, "Object A1");
A a2 = a1;
std::cout << "a1.val: " << a1.val << ", a1.name: " << a1.name << std::endl;
std::cout << "a2.val: " << a2.val << ", a2.name: " << a2.name << std::endl;

strcpy(a2.name, "Modified A2");
std::cout << "After modifying a2.name:" << std::endl;
std::cout << "a1.val: " << a1.val << ", a1.name: " << a1.name << std::endl;
std::cout << "a2.val: " << a2.val << ", a2.name: " << a2.name << std::endl;
```

得到的输出如下：
```
a1.val: 10, a1.name: Object A1
a2.val: 10, a2.name: Object A1
After modifying a2.name:
a1.val: 10, a1.name: Modified A2
a2.val: 10, a2.name: Modified A2
```

可以发现，当我们对```a2.name```进行修改后，```a1.name```也随之改变。这是由于C++的默认拷贝方式为浅拷贝，即对于基本数据类型使用赋值的方式直接拷贝，因此对于基本数据类型的指针，拷贝得到的是相同的地址。因而两个指针指向了相同的内存地址。

#### 浅拷贝的风险

对于上面的类A，首先发现的风险在前面已经出现了，就是两个类的数据会出现共享的情况，在庞大的代码中可能出现不可控的风险。

更严重的事，我们如果执行下面的代码：

```cpp
A *a1 = new A(10, "Original A1");
A *a2 = new A(*a1);
delete a1;
std::cout << a2->val << ", " << a2->name << '\n';
delete a2;
```

当我们主动释放```a1```对应的空间后，```a2```中的```name```变量也随之被主动释放，接着变成了野指针。随后我们主动释放```a2```时，还有多重释放的问题。

从上面对于该实例的分析中可以得到，浅拷贝只能对浅层数据进行拷贝。对于一些非指针的基本类型，浅拷贝不具有安全问题；但是对于指针和各种类（尤其包含原始指针、文件句柄等资源的类），浅拷贝会导致多个变量共享同一块内存的隐性问题。这种隐性问题同样是编译时不会出现，但是运行时导致错误的，包括但不限于：

- 双重释放
- 内存泄漏
- 悬空指针
- 数据意外共享

因此，在编写类的时候，我们需要主动控制对该类的拷贝方式以保证安全和可维护性。

### 深拷贝

深拷贝与浅拷贝相对，这种拷贝方式对深层数据也进行了拷贝。

#### 深拷贝的视线

如下是一种深拷贝的实现方式：

#### 评价深拷贝

容易看出，通过这种方式实现深拷贝，有效避免了浅拷贝可能出现的风险。深拷贝由于对深层数据进行拷贝，会增加很多时空成本；尽管两个对象拥有了互不干扰的独立数据，但是这也带来了更高的负担。

### 如何选择深拷贝/浅拷贝

## 运算符重载

在设计一个新的类之后，经常会出现蹩脚的问题。原本的基本数据类型诸如```int, long, char```等等可以直接进行基本运算，与C++各种原生函数/流也可以直接适配；而新类则不能。因此，我们就会自然而然地考虑想要重新定义这些运算符，这就是运算符重载。

### 运算符重载的语法基础

基于先前对于深浅拷贝的讨论，我们已经实现了一种运算符重载。顺势我们可以介绍运算符重载的一般形式。

```cpp
返回类型 operator符号 (参数列表);
```

### 对一个```bigNumber```类进行运算符重载

#### 拷贝

#### 加法

#### 大小比较

#### 相等比较

#### 流输出

### 常见的运算符重载

### 运算符重载总览

## 友元机制

先前提到，类的封装特性使得我们能够主动控制其内部成员是否可以被外部、派生类等访问，然而在实际开发中经常也会因此受限。为了降低维护成本，C++引入了```friend```关键词，实现了受控破封机制，允许非成员函数访问类的私有成员。

### 友元函数

### 友元类

## 静态成员与常量成员

类的设计是为了方便管理一类对象，我们设计类时最关注的一般也都是它们的共同特性。因此对于某些特殊的共同特性，C++也引入了关键词```static, const```用来维护这些特殊的成员。

### 静态成员(**static**)

### 常量成员(**const**)

