# Updates

续```part1.1.md```继续写

前面文章涉及了基本的面向对象的四大核心，同时也重点讨论了它们在C++中的实现方式，接下来将对C++ class的细节和行为控制进行进一步的学习探索

# 面向对象与内存管理

## 深拷贝与浅拷贝

之前文章提及了C++类的构造函数和析构函数，这是进行类初始化的基本操作。然而需要注意的一点是，在复杂工程中经常会出现拷贝的问题，而仅靠默认的构造/析构函数容易导致隐性错误的出现，进而编译正常，但运行时错误。为了尽可能避免隐性错误的出现，对拷贝方式进行学习与讨论，进而灵活设计拷贝方式是非常重要的。

### 默认下的拷贝

### 浅拷贝

### 深拷贝

## 运算符重载

在设计一个新的类之后，经常会出现蹩脚的问题。原本的基本数据类型诸如```int, long, char```等等可以直接进行基本运算，与C++各种原生函数/流也可以直接适配；而新类则不能。因此，我们就会自然而然地考虑想要重新定义这些运算符，这就是运算符重载。

### 运算符重载的语法基础

### 常见的运算符重载

### 运算符重载总览

## 友元机制

先前提到，类的封装特性使得我们能够主动控制其内部成员是否可以被外部、派生类等访问，然而在实际开发中经常也会因此受限。为了降低维护成本，C++引入了```friend```关键词，实现了受控破封机制，允许非成员函数访问类的私有成员。

### 友元函数

### 友元类

## 静态成员与常量成员

类的设计是为了方便管理一类对象，我们设计类时最关注的一般也都是它们的共同特性。因此对于某些特殊的共同特性，C++也引入了关键词```static, const```用来维护这些特殊的成员。

### 静态成员(**static**)

### 常量成员(**const**)

