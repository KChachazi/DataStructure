# 概述

C++ vector 是一种序列容器，可以称为变长数组。下面可以给出一个强有力的定义：vector 是一个**连续内存、动态增长、拥有值语义、负责对象生命周期的通用序列容器**。

# 功能目标

从抽象层面来看，vector 的功能目标即定义中的几个限制词，下文将要一一介绍。

## 连续内存

vector 与 list/deque 的根本区别在于，其要管理的是一段连续的对象序列。在内存空间中，表现为 `&v[i] + 1 == &v[i+1]`。

连续内存的要求使得 vector 可以直接与 `C API / SIMD / cache` 进行交互，带来极大的使用便利；只是直接导致在 vector 的空间中不能随便插空，在中间的插入/删除操作的时间复杂度必定为 `O(n)`，而且扩容时只能“举家搬迁”。

## 负责对象生命周期

vector<T> 不是仅仅对 T 类型的对象进行简单封装，而更是一个对象生命周期管理器。vector 必须负责分配原始内存，在内存中构造对象，在适当时机析构对象，最后释放内存。

## 拥有值语义

此处需要补充！！

## 通用序列容器

## 提供支持STL生态的接口

总的来说，vector 能做的是高效随机访问，cache-friendly 遍历，尾部插入高效，与 C 接口无缝交互；vector 明确不能保证中间插入高效，指针/迭代器稳定性，泛型下不抛异常。

# 实现

vector 有一个大体框架（如下），`capacity` 管理的是 vector 的总内存大小/最大可容纳的元素数量，`size` 管理的是 vector 已构造的元素数量。

```
┌─────────────────┐
│    allocated    │  ← capacity
│ ┌─────────────┐ │
│ │ constructed │ │  ← size
│ └─────────────┘ │
└─────────────────┘
```

| 阶段         | 内存状态 | 对象状态 |
| ---------- | ---- | ---- |
| allocate   | 有    | 没有   |
| construct  | 有    | 有    |
| destroy    | 有    | 没有   |
| deallocate | 没有   | 没有   |

解耦！！

| 接口                   | 是否抛异常 | 原因              |
| -------------------- | ----- | --------------- |
| `at()`               | 必须抛 | 接口语义承诺“安全访问”    |
| `operator[]`         | 不抛  | 接口语义承诺“高性能、无检查” |
| `front()` / `back()` | 不抛  | STL 选择相信用户      |
| `push_back`          | 不抛  | 不涉及索引           |
| `reserve`            | 不抛  | 参数非法通常是逻辑错误     |

接口取舍

emplace_back vs push_back
在 vector 的“最终存储位置”上，直接调用构造函数
先有一个对象，再把它“搬”进 vector

| 维度   | push_back | emplace_back |
| ---- | --------- | ------------ |
| 接口   | 接收 T      | 接收构造参数       |
| 临时对象 | 必然存在      | 不存在          |
| 移动构造 | 常见        | 不需要          |
| 性能   | 好         | **最好**       |
| 可读性  | 直观        | 稍复杂          |
| 异常安全 | 好         | 更好           |
